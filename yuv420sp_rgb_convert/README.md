# NV21 和 RGB 的相互转换：原理、实现和优化

## 0x0 背景

假设已经知道 NV21 是 YUV420SP 的一种， 知道 RGB 和 YUV 有像素间的相互转换公式。

从博客找到的转换代码， 用的 magic number 实在让人没信心， 另一方面也没有做 SIMD 优化性能堪忧； 即便用了 OpenCV、 xxYUV 等开源库， 代码又看的一头雾水。NV21 和 RGB 之间的转换，到底怎样转的？4个步骤依次来：

1. 选视频标准。 BT 601， BT 709， BT 2020。 每个标准下的 YUV 和 RGB 转换公式都不一样。

2. 选 full range / narrow range。 full range 就是 `[0, 255]`， narrow range 就是 `[16, 235], [16, 240]`

3. 定点化做近似计算和加速，选合适的移位数，不同位数精度不一样， 还要考虑 SIMD 实现时性能影响

4. 开源库的实现， 前3步都可能魔改， PC 和 设备上的执行的代码可能又不同， 看你是要精度还是性能， 对应不同选择

## 0x1 转换公式

关于各种选择下的公式， 这里推荐看《Video Demystified》一书的相关章节，讲解的通俗易懂； 也有整理的比较好的博客，可以直接查看： https://blog.csdn.net/sunty2016/article/details/106589379

## 0x2 定点化


## 0x3 开源库实现

- OpenCV，用的是 BT 601 narrow range 的魔改版， 定点化使用的移位是20位
- xxYUV， 用的是 BT 709， 支持 full range / narrow range 的选择
- OpenCV Android 版， 默认用 carotene 库的实现， 用的是 ？ 标准， 定点化用的移位是5位


---------------------

## 0x1 视频标准


## 0x0 放慢脚步

在做 NV21 和 RGB 相互转换时， 百度一下 -> CSDN 博客现成代码 -> 拷贝粘贴使用， 这样的步骤有潜在问题：
1. 性能不行， 通常没做 SIMD 优化
2. 系数都是 magic number ， 用的不放心
3. 不够通用， 改天需要 NV12 <=> BGR ， 拷贝然后修改，繁琐也易错

对于问题1， 优化的前提是有一份正确的 naive 实现； 而验证 naive 实现正确的前提则是知道**YUV和RGB的转换公式有多种，选择公式后定点化位数还有变数**。

## 0x1 背景

RGB 是一种颜色空间， 像素按 r1 g1 b1 r2 g2 b2 ... 连续排列。 YUV 也是一种颜色空间， NV21 是 YUV 的一种具体格式， 由两个平面（Y平面、VU交错平面）组成:

```
Y Y Y Y Y Y Y Y
Y Y Y Y Y Y Y Y
Y Y Y Y Y Y Y Y
Y Y Y Y Y Y Y Y

V U V U V U V U
V U V U V U V U
```

当计算 NV21 和 RGB 两种图像格式的相互转换， 一方面注意采样（一个 2x2 格子里的 4 个 Y 对应一组 V、U）， 另一方面注意单组 YUV 和 RGB 的转换公式； 在确定了公式的基础上， 程序实现阶段还可以适当修改公式， 在速度、精度之前权衡， 实现程序的优化。

实际上， YUV 格式根据采样、排列顺序，有很多细分， YUV420SP 是其中的一种， NV21 和 NV12 则是 YUV420SP 的进一步细分， 两者差别仅在于 U 和 V 的顺序： NV21 是先 V 再 U 的交错， NV12 则是先 U 再 V 的交错。类似的， RGB 和 BGR 格式的差别，仅仅在于 R 和 B 的顺序交换。因此， 如下4种转换， 仅仅在于UV顺序、RGB顺序不同，可以一并实现：
- NV21 => RGB
- NV12 => RGB
- NV21 => BGR
- NV12 => BGR

## 0x1 原理

YUV 和 RGB 的转换公式并不唯一。按视频标准可以选择 BT 601， BT 709， BT 2020； 选定视频标准后， 还可以在 full range （0到255范围） 和 narrow range （16到235或240范围） 之间选择； 在此基础上， 用定点化方法（浮点数倍数缩放，取近似，整数计算替代浮点计算）时会挑选的不同移位大小，会再次造成精度差异。

很多刚接触 YUV 和 NV21 格式转换的新人， 在不了解这些转换公式的弯弯绕绕的前提下， 直接搜索格式转换的代码， 容易陷入困扰： 同样的输入图像， A 博客、B 博客的代码结果不一样， C 开源库、 D开源库的结果也不一样， 该用哪个呢？

例如：
- OpenCV，用的是 BT 601 narrow range 的魔改版， 定点化使用的移位是20位
- xxYUV， 用的是 BT 709， 支持 full range / narrow range 的选择
- OpenCV Android 版， 默认用 carotene 库的实现， 用的是 ？ 标准， 定点化用的移位是5位

关于各种选择下的公式， 这里推荐看《Video Demystified》一书的相关章节，讲解的通俗易懂； 也有整理的比较好的博客，可以直接查看： https://blog.csdn.net/sunty2016/article/details/106589379


## 0x2 